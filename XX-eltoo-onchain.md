# BOLT #??: Recommendations for On-chain Eltoo Transaction Handling

## Abstract

Lightning eltoo channels allow for two parties (a local node and a remote node) to conduct transactions
off-chain by giving each of the parties a *signed update and settlement transaction*,
which describes the current state of the channel (basically, the current balance).
This *update transaction* and *settlement transactions* are updated every time a new payment is made and
is spendable at all times.

There are three ways a channel can end:

1. The good way (*mutual close*): at some point the local and remote nodes agree
to close the channel. They generate a *closing transaction* (which is similar to a
settlement transaction, but without any pending payments) and publish it on the
blockchain (see [BOLT #??: Channel Close](XX-eltoo-peer-protocol.md#channel-close)).
2. The bad way (*unilateral close*): something goes wrong, possibly without evil
intent on either side. Perhaps one party crashed, for instance. One side
publishes latest *latest update transaction*. Note that the updating peer
may not have received an ACK with partial signatures for this update.
3. The ugly way (*inavalidated unilateral close*): something goes very wrong, peer
publishes an update transaction that has been invalidated by a subsequent update.

The goal of this document is to explain exactly how a node should react when it
encounters any of the above situations, on-chain.

# Table of Contents
  * [General Nomenclature](#general-nomenclature)
  * [Update Transaction](#update-transaction)
  * [Settlement Transaction](#settlement-transaction)
  * [Failing a Channel](#failing-a-channel)
  * [Mutual Close Handling](#mutual-close-handling)
  * [Unilateral Close Handling: Invalidated Update Transaction](#unilateral-close-handling-inavalidated-update-transaction)
  * [Unilateral Close Handling: Latest Update Transaction](#unilateral-close-handling-latest-update-transaction)
  * [Unilateral Close Handling: Invalidated Settlement Transaction](#unilateral-close-handling-inavalidated-settlement-transaction)
  * [Unilateral Close Handling: Latest Settlement Transaction](#unilateral-close-handling-latest-settlement-transaction)
  * [HTLC Output Handling: Offerer](#htlc-output-handling-offerer)
  * [HTLC Output Handling: Recipient](#htlc-output-handling-recipient)
  * [Authors](#authors)

# General Nomenclature

Any unspent output is considered to be *unresolved* and can be *resolved*
as detailed in this document. Usually this is accomplished by spending it with
another *resolving* transaction. 

Outputs that are *resolved* are considered *irrevocably resolved*
once the *resolving* transaction is included in a block at least 100
deep, on the most-work blockchain. 100 blocks is far greater than the
longest known Bitcoin fork and is the same wait time used for
confirmations of miners' rewards (see [Reference Implementation](https://github.com/bitcoin/bitcoin/blob/4db82b7aab4ad64717f742a7318e3dc6811b41be/src/consensus/tx_verify.cpp#L223)).

## Requirements

A node:
  - once it has broadcast a funding transaction OR sent a signature
  for a update/settlement transaction pair that contains an HTLC output:
    - until all outputs are *irrevocably resolved*:
      - MUST monitor the blockchain for transactions that spend any output that
      is NOT *irrevocably resolved*.
  - MUST *resolve* all outputs, as specified below.
  - MUST be prepared to resolve outputs multiple times, in case of blockchain
  reorganizations.
  - upon the funding transaction being spent, if the channel is NOT already
  closed:
    - MAY send a descriptive `error`.
    - SHOULD fail the channel.
  - SHOULD ignore invalid transactions.

## Rationale

Once a local node has some funds at stake, monitoring the blockchain is required
to ensure the remote node does not close unilaterally to a inavalidated state.

Invalid transactions (e.g. bad signatures) can be generated by anyone,
(and will be ignored by the blockchain anyway), so they should not
trigger any action.

# Update Transaction

The local and remote nodes each hold a *update transaction*. 

These transactions contain a single input and output signed with
SIGHASH_SINGLE, which allows fee inputs and outputs to be added
by the broadcasting node.

Each later update transaction can be "re-bind"ed to spend
any prior funding or update output that is unresolved on the blockchain.

See [BOLT #??: Update Transaction](XX-eltoo-transactions.md#update-transaction)
for more details.

# Settlement Transaction

Each node holds a symmetrical *settlement transaction*. Each of these
settlement transactions has up to two types of outputs. For each node:

1. A node's main output_: Zero or one output, to pay a peer's
`settlement_pubkey`.
1. A node's offered HTLCs_: Zero or more pending payments (*HTLCs*), to pay
a peer in return for a payment preimage. One node's offered HTLC output is
the other node's receiving HTLC output.

As we rely on the publication of update transactions to enforce the final
state, these outputs are allowed the be spent immediately and provide
CPFP fees.

See [BOLT #??: Settlement Transaction](XX-eltoo-transactions.md#settlement-transaction)
for more details.

# Failing a Channel

Although closing a channel can be accomplished in several ways, the most
efficient is preferred for privacy and fees.

Various error cases involve closing a channel. The requirements for sending
error messages to peers are specified in
[BOLT #1: The `error` Message](01-messaging.md#the-error-message).

## Requirements

A node:
  - if the *current settlement transaction* does NOT contain a `to_node` output to itself or
other HTLC outputs:
    - MAY simply forget the channel.
  - otherwise:
    - if it has received a valid `closing_signed_eltoo` message that includes a
    sufficient fee:
      - SHOULD use this fee to perform a *mutual close*.
      - if the *mutual close* transaction fees reveal as insufficient, MAY use a CPFP output
    - otherwise:
      - if the node knows or assumes its channel state is outdated:
        - SHOULD NOT broadcast its *last update transaction*.
      - otherwise:
        - MUST broadcast the *last update transaction*, for which it has a
        signature as well as the signature and data for the settlement transaction, to perform a *unilateral close*.
          - MUST attach and spend an ephemeral anchor in order to induce inclusion in a block in a timely manner to enforce final state via CPFP
          - SHOULD use [replace-by-fee](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki) or other mechanism on the anchor spending transaction if it proves insufficient for timely inclusion in a block.
        - After `shared_delay` timeout, if the update transaction output isn't otherwise resolved, MUST broadcast the associated *settlement transaction*.
          - MUST spend the epehemeral anchor that contains the trimmed value in order to induce inclusion in a block in a timely manner to enforce final state
          - MAY spend other settlement outputs along with ephemeral anchor to include fees

## Rationale

In the early stages of a channel, it's common for one side to have
little or no funds in the channel; in this case, having nothing at stake, a node
need not consume resources monitoring the channel state.

There exists a bias towards preferring mutual closes over unilateral closes,
because outputs of the former are unencumbered by a delay and are directly
spendable by wallets. In addition, mutual close fees tend to be significantly smaller
than those required of the update and settlement transactions.
So, the only reason not to use the signature from `closing_signed_eltoo` would be if the fee
offered was too small for it to be processed.

# Mutual Close Handling

A closing transaction *resolves* the funding transaction output.

In the case of a mutual close, a node need not do anything else, as it has
already agreed to the output, which is sent to its specified `scriptpubkey` (see
[BOLT #??: Closing initiation: `shutdown_eltoo`](XX-eltoo-peer-protocol.md#closing-initiation-shutdown)).

# Unilateral Close Handling: Invalidated Update Transaction

In eltoo-based channels, there are up to `k` update transactions available
to be put into the blockchain. If the node sees the funding output
being resolved without a mutual close, action may need to be taken to ensure
the final state is claimed.

The associated settlement transaction can not be used until the `shared_delay`
relative timelock times out for the newly created state output. This delay
is what allows honest peers to ensure the final state is claimed.

## Requirements

"Rebinding" is the act of taking a pre-signed ANYPREVOUT(ANYSCRIPT) transaction,
and finalizing all the witness data, as well as modifying the prevout itself,
to spend the current unresolved state utxo. In the case of Eltoo,
this is the funding output, or any subsequent update transaction state output.
Both update and settlement transactions should be re-bound at broadcast time
to react to on-chain events properly.

A node:
  - upon discovering an *invalidated update transaction* on chain:
    - Until latest update transaction is mined or invalidated settlement transaction
      resolves the state output:
      - SHOULD estimate the cost of updating current state output to the latest update transaction
        and settlement transaction, weighing it against the value claimable on-chain by the user in the latest.
        In the degenerate case of no `to_node` outputs to itself or HTLC outputs, there is no incentive
        to claim the latest channel state.
      - Otherwise, MUST respond by publishing the latest update transaction, re-binding
        to the invalidated update transactions' state output, recovering the necessary
        control block information from the invalidated update transaction's annex field.
      - If the latest update transaction is failing to be mined within the proper window,
        package RBF replacement with a higher fee ephemeral anchor spend is recommended
        to avoid old state being successfully used and to avoid fulfilled HTLCs with incoming
        value being timed out.
    - If the latest update transaction is then confirmed:
      - MUST wait `shared_delay` blocks of confirmation for this transaction
          to publish the corresponding pre-signed *settlement transaction*
      - If no HTLCs are to be resolved, publishing the settlement transaction
        MAY be arbitrarily delayed by the node to save on fees, or use the ephemeral
        anchor spend to make another transaction such as a direct payment, channel open,
        etc. This may make recovery of funds less reliable if state is lost.

## Rationale 

In the case where we unconditionally aren't owed any funds for the latest settlement
transaction, there is no need to spend funds to recover those funds. Otherwise,
if it economically makes sense, the node wants the latest state to be confirmed.

# Unilateral Close Handling: Latest Update Transaction

In the other eltoo channel case, we see the latest channel state
be confirmed on the blockchain, and must ensure that the settlement transaction
outputs are created and then spent in a safe amount of time, for the case of
HTLC outputs.

## Requirements

A node:
  - upon discovering the *latest update transaction*:
    - MUST wait `shared_delay` blocks of confirmation for this transaction
      to publish the latest pre-signed *settlement transaction*

## Rationale

If your counter-party honestly had the latest channel state confirmed,
then the only thing to do is make sure settlement outputs are swept
as necessary.

# Unilateral Close Handling: Invalidated Settlement Transaction

In the case of a inavalidated update maturing and the settlement transaction
confirmed on the blockchain, the node must simply accept whatever
outputs it is given, even though this is an exception case. Depending
on level of inavalidatedness and channel state, a significant fraction of funds
may be recovered this way.

## Requirements

A node:
  - upon discovering a *inavalidated settlement transaction*:
    - MAY attempt to sweep any redeemable HTLC outputs
      - HTLC (pre)images may have been forgotten by the client to decrease
        client state to constant size
      - If not, attempts MAY be made to rescue these funds by grinding HTLC
        scripts and CLTVs to find the witness data to spend these HTLCs.
        - This is not recommended
    - MAY attempt to sweep its own `to_node` output
      - This is spendable based on whatever arbitrary policy the node opted into
    - MAY continue attempting to publish the latest update and settlement
      transactions bound to the state output in utxo set
      until that utxo is irrevocably resolved
        - this can be done at a high feerate versus the sweep to allow recovery of final
          state in the case of blockchain reorganization

## Rationale

It's not over until the state output is irrevocably resolved. Continue trying to
enforce correct behavior until our subjective finality limit.

# Unilateral Close Handling: Latest Settlement Transaction

## Requirements

A node:
  - upon discovering the *latest settlement transaction*:
    - MUST attempt to resolve HTLCs within the timeout windows allotted
      by the CLTV in the outputs for fulfillment case, and 
    - MAY sweep its `to_node` output

## Rationale

Only pending HTLCs are at risk, no need to resolve other outputs unless otherwise required.

Claiming the HTLCs should be fee-bumped with RBF during the timeout windows, if the original
fee is insufficient.

## HTLC Output Handling: Offerer

Each HTLC output can only be spent by either the *offerer*, by spending the
output  after it's timed out, or the *recipient*, if it
has the payment preimage.

There can be HTLCs which are not represented by any outputs: either
because they were trimmed as dust, or because the transaction has only been
partially committed.

The HTLC output has *timed out* once the height of the latest block is equal to
or greater than the HTLC `cltv_expiry`.

### Requirements

An offering node:
  - if the settlement transaction HTLC output is spent using the payment
  preimage, the output is considered *irrevocably resolved*:
    - MUST extract the payment preimage from the transaction input witness.
  - if the settlement transaction HTLC output has *timed out* and hasn't been
  *resolved*:
    - MUST *resolve* the output by spending it using their own `settlement_pubkey` to
      any address deemed necessary.
    - once the resolving transaction has reached reasonable depth:
      - MUST fail the corresponding incoming HTLC (if any).
  - for any committed HTLC that has been trimmed:
    - once the update transaction that spent the funding output has reached reasonable depth(FIXME or just been spent? fast fail everyhting?):
      - MUST fail the corresponding incoming HTLC (if any).
    - if no *valid* commitment transaction contains an output corresponding to
    the HTLC.
      - MAY fail the corresponding incoming HTLC sooner.

### Rationale

Rationale is largely the same as BOLT05, but with no second-stage transactions
to resolve the HTLCs.

## HTLC Output Handling: Recipient

Each HTLC output can only be spent by the recipient using the HTLC preimage.
If it doesn't have the preimage (and doesn't discover it), it's
the offerer's responsibility to spend the HTLC output once it's timed out.

There are only two possible cases for an offered HTLC:

1. The offerer is irrevocably committed to the offered HTLC, but the recipient
   has not yet committed to an outgoing HTLC. In this case, the recipient can
   either forward or fail the offered HTLC.
1. The recipient has committed to an outgoing HTLC, in exchange for the offered
   HTLC. In this case, the recipient must use the preimage, once it receives it
   from the outgoing HTLC; otherwise, it will lose funds by sending an outgoing
   payment without redeeming the incoming payment.

The missing case compared to ln-penalty channels is the case where the offerer
is not yet irrevocably committed. Due to the symmetrical transaction, the offerer
is immediately irrevocably committed on sending a `commitment_signed_eltoo`.

### Requirements

A receiving node:
  - if it receives (or already possesses) a payment preimage for an unresolved
  HTLC output that it has been offered AND for which it has committed to an
  outgoing HTLC:
    - MUST *resolve* the output by spending it using the preimage.
    - MUST NOT reveal its own preimage when it's not the final recipient.<sup>[Preimage-Extraction](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002857.html)</sup>
  - If the output is spent (as is recommended), the output is *resolved* by
the spending transaction.
  - If it's NOT otherwise resolved, once the HTLC output has expired, it is
considered *irrevocably resolved*.

# General Requirements

A node:
  - upon discovering a transaction that spends a funding transaction output
  which does not fall into one of the above categories (mutual close, unilateral
  close, or revoked transaction close):
    - MUST warn the user of potentially lost funds.
      - Note: the existence of such a rogue transaction implies that its private
      key has leaked and that its funds may be lost as a result.
  - MAY simply monitor the contents of the most-work chain for transactions.
    - Note: on-chain HTLCs should be sufficiently rare that speed need not be
    considered critical.
  - MAY monitor (valid) broadcast transactions (a.k.a the mempool).
    - Caution: Reacting on transactions broadcasted in the local node mempool may unsafe as a
      counterparty could either discover the full-node associated to the LN node or
      lock-up fee-bumping reserves of the LN node if settlement outputs aren't being
      exclusively used for fees.

# Authors

[FIXME:]

![Creative Commons License](https://i.creativecommons.org/l/by/4.0/88x31.png "License CC-BY")
<br>
This work is licensed under a [Creative Commons Attribution 4.0 International License](http://creativecommons.org/licenses/by/4.0/).
